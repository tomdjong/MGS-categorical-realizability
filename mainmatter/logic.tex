\chapter{The realizability interpretation of logic}\label{chap:logic}

In this chapter we explore some of the logical aspects of the category of
assemblies over a pca.
%
% Assemblies over Kleene's first model (\cref{ex:Kleene-1}) are of particular
% interest to us as we explore concepts from computability theory, such as
% computably enumerable sets, from a logical perspective.
%
The theory of categorical logic informs us that any sufficiently structured
category supports an interpretation of logic.
%
% The amount of structure in the category determines the richness of the logic it
% supports.
For example, in a regular category we can interpret a fragment of
first order logic known as regular logic, while we can interpret higher order
logic in a topos.
%
We include a brief introduction to categorical logic in
\cref{sec:categorical-logic}, but for a proper treatment we refer the reader to
the textbooks \cite{FreydScedrov1990} (first order logic),
\cite{LambekScott1986,MacLaneMoerdijk1994} (higher order logic), or the lecture
notes~\cite{vanOosten2016} (regular logic) and \cite{Streicher2004} (higher
order logic).
%
The key point is this:
\begin{quote}
  Categorical logic gives us a \emph{uniform} way of interpreting logic in any
  sufficiently structured category.
\end{quote}
%
Following Bauer's exposition in \cite{Bauer2023} we describe how to interpret
logic in the category of assemblies via the notion of a \emph{realizability
  predicate} on an assembly.
%
We emphasize that this is \emph{not} some ad-hoc interpretation. Rather, it is a
convenient unfolding of the uniform interpretation given to us by categorical
logic.
%
The structure established on the category of assemblies in
\cref{chap:assemblies} allows us to interpret full first order logic.

Having said all of this, the reader who finds themselves ill at ease with
categorical logic can find solace in the fact that the
particular---realizability---interpretation of logic is spelled out in more
elementary terms in \cref{sec:cat-logic-in-asm} and
\cref{sec:realizability-interpretation} in particular.

After establishing that the logic in the category of assemblies is given by
realizability predicates, \cref{sec:two-element-assemblies} isolates three
particular classes of such predicates by logical means. These are the
\(\lnot\lnot\)\nobreakdash-stable, decidable and semidecidable realizability
predicates.
%
In assemblies over Kleene's first model these are shown to respectively
correspond to ordinary (classical) subsets, computable subsets and computably
enumerable subsets.

Finally, \cref{sec:synthetic} illustrates the intimate connections between
logic, computability and categories via \emph{synthetic computability
  theory}~\cite{Bauer2006}. Specifically, we give a synthetic proof of a
fundamental result in computability theory: a subset of the natural numbers is
computable if and only if it and its complement are computably enumerable.


\section{Categorical logic in a nutshell}\label{sec:categorical-logic}
Suppose we have a formula \(\phi(x)\) with a free variable \(x\). If we
interpret \(x\) to range over some set \(X\), then \(\phi(x)\) determines a
subset of \(X\), namely \(\set{x \in X \mid \phi(x)}\), the subset of elements
\(x\) of \(X\) for which \(\phi(x)\) holds.
%
A conjunction of formulas also determines a subset: the
intersection of the subsets determined by \(\phi\) and \(\psi\):
\[
  \set{x \in X \mid \phi(x) \land \psi(x)}
  = \set{x \in X \mid \phi(x)} \cap \set{x \in X \mid \psi(x)}.
\]
Similarly, with conjunction and union of course.
%
The formulas \(\top\) (truth) and \(\bot\) (falsity) determine the two extreme
subsets \(X\) and \(\emptyset\), respectively.
%
The subsets of \(X\) are a partial order when equipped with the subset
relation. Its greatest element is \(X\), its least element is \(\emptyset\), the
intersection of two subsets is the greatest lower bound of the two subsets,
while the least upper bound is given by the union.
%
Thus, we see that we can interpret a formula as a subset and that the logical
connectives are interpreted using operations (characterized by universal
properties) on subsets.

\paragraph{From subsets to monos}
In categorical logic, we generalize this from the category of sets to arbitrary,
sufficiently rich categories.
%
Instead of subsets we consider monomorphisms, or really
\emph{subobjects}\footnote{A subobject of \(X\) is a monomorphism into
  \(X\) up to isomorphism in the slice category over \(X\).}.
%
The monos into a fixed object \(X\) in a category form a preorder by setting
\((M \hookrightarrow X) \preceq (N \hookrightarrow X)\) if we have a map
\(M \to N\) making the triangle
\[
  \begin{tikzcd}[row sep=4mm,column sep=4mm]
    M \ar[dr] \ar[rr,hookrightarrow] & & X \\
    & N \ar[ur,hookrightarrow]
  \end{tikzcd}
\]
commute. (One can check that the map \(M \to N\) is necessarily a mono.)

This preorder generalizes the subsets with their subset relation.
%
The relation \(\preceq\) is reflexive and transitive, but not necessarily
antisymmetric. But we can consider the \emph{poset reflection} of this preorder,
where we quotient such that monos \(M \hookrightarrow X\) and
\(N \hookrightarrow X\) are identified when \(M \preceq N\) and \(N \preceq M\)
both hold.
%
One may check that an element of the resulting poset is precisely a subobject.

\paragraph{Logical connectives and monos}
The formula \(\top\) is interpreted as the greatest element in the preorder of
monos into \(X\), i.e.\ as \(\id_X \colon X \to X\).
%
The formula \(\bot\) is interpreted as the least element in the preorder of
monos into \(X\), which in a cartesian closed category with an initial object
\(0\) (like the category of assemblies) indeed exists and is given by the unique
map\footnote{The proof that this map is indeed a mono is short, but surprisingly
  tricky. The interested reader might like to prove it for themselves. In case
  they get stuck, see \cite[Theorem~6.3]{McLarty1992} or \cite{NCF}.}
\(0 \to X\).

Following the universal properties of subsets, we deduce that conjunction should
be interpreted using the greatest lower bound in the preorder of monos.
%
Assuming our category has pullbacks, one can check that taking the pullback
\[
  \begin{tikzcd}
    M \land N \pbcorner \ar[d,hookrightarrow] \ar[r,hookrightarrow]
    & N \ar[d,hookrightarrow] \\
    M \ar[r,hookrightarrow] & X
  \end{tikzcd}
\]
of two monos into \(X\) gives their greatest lower bound
\(M \land N \hookrightarrow X\).
%
(In the diagram all maps are monos because those are stable under pullback.)

Interpreting disjunction is slightly more involved: for two monos
\({M,N \hookrightarrow X}\) the induced map \(M + N \to X\) from the coproduct is
not in general a mono. Instead, we require that the category factors any map as
a regular epi followed by a mono (like we have in the category of assemblies by
\cref{exer:reg-epi-mono-factorization}) and we factor \(M + N \to X\) as
\(M + N \twoheadrightarrow M \lor N \hookrightarrow X\).

It is an insight of Lawvere~\cite{Lawvere1969} that the quantifiers \(\forall\)
and \(\exists\) can also be suitably captured by universal properties using
adjunctions.
%
Any morphism of the category \(f \colon X \to Y\) induces a monotone map
\(f^\ast \colon \Mono(Y) \to \Mono(X)\) on the preorders of monos into \(Y\) and
\(X\) respectively by pulling back along \(f\).
%
Viewing these preorders as categories, the map \(f^\ast\) has a right adjoint
\(\exists_f\) by defining \(\exists_f(m)\) to be the monomorphism part of the
factorization of \(f \circ m\) as a regular epi followed by a mono.
%
For the universal quantifier, we then require \(f^\ast\) to also have a right
adjoint which we denote by \(\forall_f\).
%
For locally cartesian closed categories, like the category of assemblies
(\cref{base-change-adjoints}), we already have a right adjoint \(\prod_f\) to the
pullback functor which, being a right adjoint, preserves monos and hence
restricts to a monotone map on the preorders of monos.

\paragraph{Sorts, relations and terms}
We assume to be given a many-sorted language. This means that variables,
function symbols and relation symbols are typed by an assignment of
\emph{sorts}.
%
The sort of a variable indicates what it is supposed to range over.
%
Function symbols have a source and target sort and relation symbols have as many
sorts as their arity.
%
For example, if we are interested in arithmetic we might have a single sort
\(N\) for the natural numbers and a function symbol \(s\) for the successor map
with source and target sort \(N\).
%
We can build terms by e.g.\ applying a function symbol to a variable, subject to
the condition that the sorts match up of course.

An interpretation of the language in the category is given by several assignments:
\begin{itemize}
\item each sort \(X\) is interpreted as an object \(\sem{X}\) of the category;
\item each function symbol \(f\) with source sort \(S\) and target sort \(T\) is
  interpreted as an arrow \(\sem{f} \colon \sem{S} \to \sem{T}\) in the
  category;
\item each relation symbol \(R\) with sorts \(X_1,\dots,X_n\) is interpreted as
  a subobject \(\sem{R}\) of the product
  \(\sem{X_1}\times\cdots\times\sem{X_n}\).
\end{itemize}

We can also interpret equality of two terms \(s\) and \(t\) by taking the
equalizer of their interpretations \(\sem{s}\) and \(\sem{t}\).

For the example of the language of arithmetic, it would make good sense to
require the category to have a natural numbers object and to use this as the
interpretation of the sort of the natural numbers.
%
If we added sorts \(N^N\), \(N^{\pa*{N^N}}\), etc.\ for functions then we would
interpret these using exponentials in a cartesian closed category.

The purpose of the above is that it tells us that a formula \(\phi(x)\) with a
free variable \(x\) of sort \(X\) should be interpreted as a monomorphism into
\(\sem{X}\), i.e.\ it tells us which object to consider.
%
The actual interpretation of \(\phi(x)\) as mono into \(\sem{X}\) can then be
calculated by recursion on the structure of \(\phi\).
%
(If \(\phi\) has more than one free variable, say \(x_1,\dots,x_n\) of sorts
\(X_1,\dots,X_n\), respectively, then we simply consider the object
\(\sem{X_1} \times \cdots \times \sem{X_n}\).)

We write \(\forall(x : X).\phi(x)\) and \(\exists(x : X).\phi(x)\) when
quantifying over a sort \(X\). The colon (:) should remind us that
these quantifications are interpreted in the category.

\paragraph{Internal language}
Given a category \(\mathcal C\), a particular language we might consider is the
\emph{internal language} of \(\mathcal C\) where we add a sort for each object
of \(\mathcal C\), a function symbol for each morphism of \(\mathcal C\),
and finally a relation symbol for each subobject of \(\mathcal C\).
%
This language has a natural interpretation in \(\mathcal C\): if we added a sort
for an object \(X\), then the interpretation of that sort is \(X\); and
similarly for the function and relation symbols.
%
In this case we do not distinguish notationally between the object and the sort,
the function symbol and the morphism, and the relation symbol and the subobject.

\paragraph{Soundness}
One can show that the poset of subobjects is always a \emph{Heyting algebra}
whenever the category has sufficient structure (e.g.\ when it is regular and the
adjoint \(\forall_f\) exists).
%
As a consequence we have:
\begin{theorem*}[Soundness theorem]
  If we can prove \(\psi\) from \(\phi\) in constructive logic, then
  \(\sem{\phi} \preceq \sem{\psi}\) holds in the poset of subobjects.
\end{theorem*}

The subobjects do \emph{not} usually form a \emph{Boolean algebra}, however,
which means we do not have soundness with respect to classical logic, i.e.\ the
law of excluded middle may not be validated by the interpretation in the
category.


\section{Categorical logic in categories of assemblies}\label{sec:cat-logic-in-asm}

We wish to describe the logical side of the category of assemblies. By
\cref{sec:categorical-logic} this means studying the monomorphisms of
\(\Asm{\AA}\).
%
As often, it is advisable to first find a more convenient description of the
monos in this category. For example, in the category of sets, it is often useful
to work with subsets instead of injections, and in the category of presheaves on
a category we similarly often choose to work with subpresheaves.
%
Following Bauer~\cite{Bauer2023}, we choose the preorder of \emph{realizability
  predicates} on an assembly \(X\) as a convenient substitute for the preorder of
monos into \(X\).
%


\begin{definition}[Realizability predicate]
  A \textbf{realizability predicate} on an assembly~\(X\) is a function
  \(\carrier{X} \to \PA\).
\end{definition}

Note that the definition of a realizability predicate makes sense even when
\(X\) is just a set and not an assembly. However, we will shortly define a
preorder on realizability predicates on an assembly \(X\) which \emph{does} make
essential use of the realizers of \(X\).

\begin{notation}
  We will typically write \(\phi\) and \(\psi\) for realizability predicates.
\end{notation}

We think of a realizability predicate \(\phi\) on \(X\) as a logical predicate
on \(X\), and of \(\phi(x)\) as the set of witnesses that \(\phi\) holds for the
element \(x\).

\begin{definition}[Preorder on realizability predicates, \(\phi \predleq \psi\)]
  For two realizability predicates \(\phi\) and \(\psi\) on an assembly \(X\),
  we put \( \phi \predleq \psi \) exactly if there exists \(\pca{r} \in \AA\)
  such that, for every \(x \in \carrier{X}\), realizer \(\pca{a} \realizes_X x\)
  and witness \(\pca{b} \in \phi(x)\), we have
  \(\pca{r}\pca{a}\pca{b} \in \psi(x)\),
  %   \phi \predleq \psi \iff
  %   \exists(\pca{r} \in \pca{\AA}).
  %   \forall (x \in X).
  %   \forall(\pca{a} \realizes_X x).
  %   \forall(\pca{b} \in \phi(x)).
  %   \pca{r}\pca{a}\pca{b} \in \psi(x),
  % \]
  where we implicitly include the requirement that \(\pca{r}\pca{a}\pca{b}\) is defined.
\end{definition}

Intuitively, we have \(\phi \predleq \psi\) exactly if we can effectively
calculate a witness that \(\psi\) holds at \(x\) from a witness that \(\phi\)
holds at \(x\) \emph{and} a realizer of \(x\).
%
It is at this last point that we make essential use of the fact that \(X\) is an
assembly and not just a set.

%
It is straightforward (and similar to checking that assemblies with assembly
maps form a category) to check that \(\predleq\) is indeed a preorder, i.e.\
that it is reflexive and transitive.

\begin{notation}[Preorder of realizability predicates, \(\realpred(X)\)]
  We write \(\realpred(X)\) for the preorder of realizability predicates on an
  assembly \(X\).
\end{notation}

Every monomorphism \(m \colon Y \hookrightarrow X\) into an assembly \(X\)
determines a realizability predicate \(\phi_m\) on \(X\) by:
\begin{align*}
  \phi_m(x) &\coloneqq
  \set{\pca{a} \in \AA \mid y \in m^{-1}(x) \text{ and} \pca{a} \realizes_Y y} \\
  &\hspace{3.5pt}=
  \set{\pca{a} \in \AA \mid
    \exists(y \in \carrier{Y}).\pca{a} \realizes_Y y \text{ and } m(y) = x}.
\end{align*}
%
Notice that the \(y \in \carrier{Y}\) is necessarily unique (if it exists),
because \(m\) is injective.

Conversely, every realizability predicate on \(X\) determines a monomorphism of
assemblies \([\phi] \hookrightarrow X\) via:
\begin{align*}
  \carrier{[\phi]} &\hspace{8.5pt}\coloneqq\hspace{8.5pt}
                     \set{x \in \carrier{X} \mid \phi(x) \neq \emptyset} \\
  \pcapair\pca{a}\pca{b} \realizes_{[\phi]} x
  &\iff \pca{a} \realizes_X x
  \text{ and }
  \pca{b} \in \phi(x),
\end{align*}
where the inclusion \([\phi] \hookrightarrow X\) is tracked by \(\pcafst\).

\begin{proposition}\label{preorders-mono-predicates-iso}
  For an assembly \(X\), the above constructions constitute an equivalence
  between the preorder of monos into \(X\) and the preorder of
  realizability predicates on \(X\).
\end{proposition}
\begin{exercise}\label{exer:preorders-monos-predicates-iso}
  Prove the proposition.
\end{exercise}


\subsection{The Heyting prealgebra of realizability predicates}%
\label{sec:Heyting-prealgebra-realizability-predicates}

We describe the structure on the preorder of realizability
predicates required for interpreting first order logic.
%
The interpretation itself is detailed in
\cref{sec:realizability-interpretation}.

\begin{definition}
  There are two extreme examples of realizability predicates on an assembly \(X\):
  \begin{align*}
    \bot(x) &\coloneqq \emptyset, \\
    \top(x) &\coloneqq \AA.
  \end{align*}
  For realizability predicates \(\phi\) and \(\psi\) on a set \(X\), we define
  three new realizability predicates on \(X\) by:
  \begin{align*}
  %\item
    (\phi \land \psi)(x) &\coloneqq \set{\pcapair\pca{a}\pca{b} \mid
      \pca{a} \in \phi(x) \text{ and } \pca{b} \in \psi(x)}, \\
  %\item
    (\phi \lor \psi)(x) &\coloneqq
    \set{\pcaleft\pca{a} \mid \pca{a} \in \phi(x)} \cup
    \set{\pcaright\pca{b} \mid \pca{b} \in \psi(x)},
                          \quad(\text{recall~\cref{coproducts}}) \\
    % \item
    (\phi \Rightarrow \psi)(x) &\coloneqq
    \set{\pca{r} \in \AA \mid \text{for every}
    \pca{a} \in \phi(x) \text{ we have} \pca{r}\pca{a} \in \psi(x)}.
  \end{align*}
\end{definition}

\begin{exercise}\label{exer:predicates-heyting-prealgebra}
  Check that \(\bot\), \(\top\), \(\land\), \(\lor\) and \(\Rightarrow\) as
  defined above make the preorder \(\realpred(X)\) of realizability predicates
  on an assembly \(X\) into a Heyting prealgebra.

  (For a short definition of the latter: it is a preorder that, when viewed as a
  category, has finite (co)limits and exponentials.)
\end{exercise}

In light of \cref{preorders-mono-predicates-iso} and the fact that the Heyting
(pre)algebra operations are characterized by universal properties we know that
the operations defined above correspond to the relevant operations on monos. For
example, \([\bot]\) is the monomorphism \(0 \hookrightarrow X\) and
\([\phi\land\psi]\) is the meet (= greatest lower bound) of the monos \([\phi]\)
and \([\psi]\).

The interpretation of the quantifiers is given by adjoints, as briefly discussed
in \cref{sec:categorical-logic}. We explicitly describe these adjoints in terms
of the preorder of realizability predicates, where the
natural-bijection-between-hom-sets definition of adjoints simplifies to the
condition of a (monotone) \emph{Galois connection}: a map \(l\) between preorders is
left adjoint to \(r\) exactly when \(l(x) \leq y \iff x \leq r(y)\) holds.

\begin{proposition}
  For an assembly map \(f \colon X \to Y\) and a realizability predicate
  \(\phi\) on~\(X\), the realizability predicate \(\forall_f(\phi)\) on \(Y\)
  defined by
  \[
    {\forall_f(\phi)}\,(y) \coloneqq
    \set{\pca{t} \in \AA \mid
      \text{for every } x \in f^{-1}(y) \text{ and } \pca{a} \realizes_X x, \text{we have}
      \pca{t}\pca{a} \in \phi(x)}
  \]
  satisfies
  \[
    f^\ast(\psi) \predleq \phi \iff \psi \predleq \forall_f(\phi)
  \]
  for all realizability predicates \(\psi\) on \(Y\).

  In other words, \(\forall_f \colon \realpred(X) \to \realpred(Y)\) is a right
  adjoint to \(f^\ast \colon \realpred(Y) \to \realpred(X)\).
\end{proposition}
\begin{proof}
  We spell out what each of \(f^\ast(\psi) \predleq \phi\) and
  \(\psi \predleq \forall_f(\phi)\) amounts to.

  The former requires the existence of an element \(\pca{r_1} \in \AA\) such that
  for every \(x \in \carrier{X}\), \(\pca{a} \realizes_X x\) and
  \(\pca{c} \in \psi(f(x))\), we have \(\pca{r_1}\pca{a}\pca{c} \in \phi(x)\).

  The latter requires the existence of an element \(\pca{r_2} \in \AA\) such
  that for every \(y \in \carrier{Y}\), \(\pca{b} \realizes_Y y\) and
  \(\pca{c} \in \psi(y)\) we have
  \(\pca{r_2}\pca{b}\pca{c} \in \forall_f(\phi)\,(y)\).
  %
  That is, \(\pca{r_2}\pca{b}\pca{c}\) should satisfy
  \(\pca{r_2}\pca{b}\pca{c}\pca{a} \in \phi(x)\) for all
  \(\pca{a} \realizes_X x\) with \(f(x) = y\).

  Now notice that given such an \(\pca{r_1}\), the program
  \(\lambdapca{vwu}{\pca{r_1}u\,w}\) does the job of \(\pca{r_2}\).

  Conversely, given such an \(\pca{r_2}\), the program
  \(\lambdapca{uw}{\pca{r_2}(\pca{t_f}u)\,w\,u}\), where \(\pca{t_f}\) is a
  tracker of \(f\), does the job of \(\pca{r_1}\).
\end{proof}

For an alternative proof, one may verify that \(\forall_f(\phi)\) is the
realizability predicate determined by the monomorphism \(\prod_f([\phi])\),
where we recall \(\prod_f\) from \cref{base-change-adjoints}.

\begin{proposition}
  For an assembly map \(f \colon X \to Y\) and a realizability predicate
  \(\phi\) on~\(X\), the realizability predicate \(\exists_f(\phi)\) on \(Y\)
  defined by
  \[
    {\exists_f(\phi)}\,(y) \coloneqq
    \bigcup_{x \in f^{-1}(y)}\set{\pcapair\pca{a}\pca{b}
      \mid \pca{a} \realizes_X x \text{ and } \pca{b} \in \phi(x)}
  \]
  satisfies
  \[
    \exists_f(\phi) \predleq \psi \iff \phi \predleq f^\ast(\psi)
  \]
  for all realizability predicates \(\psi\) on \(Y\).

  In other words, \(\exists_f \colon \realpred(X) \to \realpred(Y)\) is a left
  adjoint to \(f^\ast \colon \realpred(Y) \to \realpred(X)\).
\end{proposition}
\begin{exercise}\label{exer:exists-predicate}
  Prove the proposition either directly or by checking that \(\exists_f(\phi)\)
  is the realizability predicate \(\phi_m\) determined by \(m\) in the
  factorization of the top composite
  \[
    \begin{tikzcd}[row sep=2mm,column sep=8mm]
      {[\phi]} \ar[dr] \ar[r,hookrightarrow] & X \ar[r,"f"] & Y \\
      & M \ar[ur,hookrightarrow,"m"']
    \end{tikzcd}
  \]
  as a regular epimorphism followed by a monomorphism
  (recall~\cref{exer:reg-epi-mono-factorization}).
  %
  % In other words, that \(\exists_f(\phi)\) is the realizability predicate
  % corresponding to the mono \(\exists_f([\phi])\).
\end{exercise}

In the situations that will be of us interest to us, \(f\) will also be
surjective when we consider \(\forall_f\) and \(\exists_f\).
%
If this is the case, then \(\forall_f(\phi)\) admits a definition that is more
symmetric to that of \(\exists_f(\phi)\), because in this case we have
%\begin{exercise}\label{exer:forall-predicate-surjective}
\[
  \forall_f(\phi)\,(y) = \bigcap_{x \in f^{-1}(y)}
  \set{\pca{t} \in \AA \mid
    \pca{t}\pca{a} \in \phi(x) \text{ for all} \pca{a} \realizes_X x}
\]
for any realizability predicate \(\phi\) on \(X\).
% \end{exercise}

\subsection{The realizability interpretation of logic}\label{sec:realizability-interpretation}

Suppose we are given a formula \(\phi\) in a language whose sorts and relation
and function symbols have been assigned an interpretation in \(\Asm{\AA}\).
%
If \(\phi\) has free variables \(x_1,\dots,x_n\) of sorts \(X_1,\dots,X_n\),
then, following the preceding development, we may interpret \(\phi\) as a
realizability predicate on the assembly \(\sem{X_1} \times \cdots\times \sem{X_n}\).
%
We write \(\sem{\phi}\) for this predicate. Thus, for each
\(\vec x \in \carrier*{\sem{X_1}\times\cdots\times\sem{X_n}}\), we have a subset
\(\sem{\phi}(\vec x) \subseteq \AA\) of realizers.

Using the constructions of
\cref{sec:Heyting-prealgebra-realizability-predicates} we prove the following
recursive characterization of membership of such subsets, where we use
\(\vec x_{|_\phi}\) for the restriction of a tuple to those elements that
pertain to the domain of \(\sem{\phi}\) (and similarly for terms).

\begin{proposition}\label{realizability-logic}
  The realizability predicates arising from first order logic obey
  \begin{alignat*}{2}
    &\pca{r} \in \sem{s = t}(\vec x)
    &&\quad\iff\quad \sem{t}\pa*{\vec x_{|_t}} = \sem{s}\pa*{\vec x_{|_s}} \\[5pt]
    &\pca{r} \in \sem{\bot}(\vec x)
    &&\quad\iff\quad \text{never}, \\[5pt]
    &\pca{r} \in \sem{\top}(\vec x)
    &&\quad\iff\quad \text{always}, \\[5pt]
    &\pca{r} \in \sem{\phi \land \psi}(\vec x)
    &&\quad\iff\quad \pcafst\pca{r}\in\sem{\phi}\pa[\big]{\vec x_{|_\phi}} \text{ and }
       \pcasnd\pca{r}\in\sem{\psi}\pa[\big]{\vec x_{|_\psi}} \\[5pt]
    &\pca{r} \in \sem{\phi \lor \psi}(\vec x)
    &&\quad\iff\quad
       \pa[\Big]{\pca{r} = \pcaleft\pca{r'}
       \text{ and } \pca{r'}\in \sem{\phi}\pa[\big]{\vec x_{|_\phi}}}
       \text{ or } \\%[5pt]
    & &&\hspace{60pt} \pa[\Big]{\pca{r} = \pcaright\pca{r'}
         \text{ and } \pca{r'}\in \sem{\psi}\pa[\big]{\vec x_{|_\psi}}}, \\[5pt]
    &\pca{r} \in \sem{\phi \Rightarrow \psi}(\vec x)
    &&\quad\iff\quad \text{if } \pca{a} \in \sem{\phi}\pa[\big]{\vec x_{|_\phi}}, \text{then }
       \pca{r}\pca{a} \in \sem{\psi}\pa[\big]{\vec x_{|_\psi}}, \\[5pt]
    &\pca{r} \in \sem{\forall(x : X).\phi}(\vec x)
    &&\quad\iff\quad \text{if } x \in \carrier{\sem{X}}
       \text{ and } \pca{a} \realizes_{\sem{X}} x, \text{then }
       \pca{r}\pca{a} \in \sem{\phi}(\vec x,x), \\[5pt]
    &\pca{r} \in \sem{\exists(x : X).\phi}(\vec x)
    &&\quad\iff\quad \text{there is an } x \in \carrier{\sem{X}}
       \text{ such that} \\%[5pt]
    & &&\phantom{\hspace{60pt}} \pcafst\pca{r} \realizes_{\sem{X}} x \text{ and }
         \pcasnd\pca{r} \in \sem{\phi}(\vec x,x).
  \end{alignat*}
\end{proposition}

A \emph{closed} formula \(\phi\) corresponds to a realizability predicate on
\(\One\) and may thus be identified with a single subset of \(\AA\).
%
We say that such a \(\phi\) is \textbf{realized}, or \textbf{valid in
  \(\Asm{\AA}\)} if we have an element of this subset.

If we take \(\AA \coloneqq \Kone\) and consider the language of arithmetic, then
we recover Kleene's original \emph{number realizability}~\cite{Kleene1945}.
%
The choice of \(\AA \coloneqq \Ktwo\) and the language of analysis recovers
Kleene's \emph{function realizability}~\cite{KleeneVesley1965}.
%

\cref{realizability-logic} may appear to be a formalization of the so-called
\emph{Brouwer--Heyting--Kolmogorov (BHK) interpretation} and is often presented
as such, although van Oosten argues this is not historically
accurate~\cite[p.~241]{vanOosten2002}. We also point out that Kleene's
realizability predates the Curry--Howard correspondence.


It is worth spelling out the realizability interpretation of (double) negation.
%
Recall that \(\lnot\phi\) is defined as \(\phi \Rightarrow \bot\), so that we
have:
\begin{lemma}%[Realizability interpretation of (double) negation]
  The realizability predicates interpreting (double) negations satisfy
  \begin{alignat*}{2}
    &\pca{r} \in \sem{\lnot\phi}(\vec x) &&\quad\iff\quad
    \sem{\phi}(\vec x) = \emptyset, \\
    &\pca{r} \in \sem{\lnot\lnot\phi}(\vec x) &&\quad\iff\quad
    \sem{\phi}(\vec x) \neq \emptyset.
  \end{alignat*}
\end{lemma}

In particular, we see that \(\sem{\lnot\lnot\phi}(\vec x)\) has no computational
content as any element of \(\AA\) acts as a realizer whenever
\(\sem{\phi}(\vec x)\) is nonempty.
%
This suggests a connection to the functor \(\nabla \colon \Set \to \Asm{\AA}\)
(from \cref{sec:relation-to-Set}) which we indeed explore in
\cref{sec:double-negation-stable}.

We repeat that the realizability interpretation of first order logic---by virtue
of the Heyting prealgebra structure---validates constructive logic, i.e.\ first
order logic without excluded middle.
%
In fact, as \cref{exer:not-double-negation-stable-predicate} shows, the logic
governing realizability predicates is never classical unless the pca is
trivial (in which case the category of assemblies is the familiar category of
sets).

\subsection{Revisiting (regular) epis and monos}\label{sec:revisiting-epis-monos}

A nice way of getting some familiarity with realizability logic is by proving
the following characterizations of (regular) epis and monos in the internal
logic of \(\Asm{\AA}\).
%
We recall our convention to use the same letters for both the formal symbol in
the internal language and its interpretation in the category, e.g.\ if \(f\) is
an assembly map, then we formally have a function symbol
\(\ulcorner f \urcorner\) in our language with interpretation
\(\sem{\ulcorner f \urcorner} \coloneqq f\); but we'll simply reuse the letter
\(f\) for this function symbol.

To appreciate \cref{exer:epis-monos-logically}, recall that an assembly map is
an epi if and only if it's surjective, while it's regular epi if and only if
it's surjective \emph{and} we have an element in~\(\AA\) that witnesses
surjectivity (\cref{exer:characterize-regular-epis}).
%
This difference in computational content is reflected in the (non)use of the
double negation in the first items of the exercise below.

\begin{exercise}\label{exer:epis-monos-logically}
  Use \cref{exer:characterize-regular-monos,exer:characterize-regular-epis} to
  show that for an assembly map \({f \colon X \to Y}\), we have the following
  logical characterizations:
  \begin{enumerate}[(i)]
  \item \(f\) is a regular epimorphism if and only if
    \[
      \forall(y : Y).\exists(x : X).f(x) = y
    \]
    is realized;
  \item \(f\) is an epimorphism if and only if
    \[
      \forall(y : Y).\lnot\lnot({\exists(x : X).f(x) = y})
    \]
    is realized;
  \item \(f\) is a monomorphism if and only if
    \[
      \forall(x, x' : X).(f(x) = f(x') \Rightarrow x = x')
    \]
    is realized;
  \item \(f\) is a regular monomorphism if and only if
    \[
      \forall(y : Y).\pa*{\lnot\lnot\pa*{\exists(x : X).f(x) = y} \Rightarrow \exists!(x : X).f(x) = y}
    \]
    is realized.

    The quantifier \(\exists!\) means ``there exists a unique \dots with \dots''.

    Phrased in English, \(f\) is a regular monomorphism if and only if the statement
    \begin{quote}{``For all \(y\), if the preimage of \(f\) at \(y\) is nonempty,
        then we can (effectively) find a unique \(x\) with \(f(x) = y\).''}
    \end{quote}
    is realized.
  \end{enumerate}
\end{exercise}


\section{Two-element assemblies as classifiers}\label{sec:two-element-assemblies}

This section introduces three sets of realizability predicates, namely the
\emph{\(\lnot\lnot\)-stable}, \emph{decidable} and \emph{semidecidable}
predicates.
%
These are shown to be \emph{classified} by three different assemblies all of
which have the set \(\set{0,1}\) as their carriers, but different realizers.
%
For example, the \(\lnot\lnot\)-stable realizability predicates are classified
by \(\nabla\set{0,1}\), while the assembly \(\Two\) of booleans classifies the
decidable realizability predicates.
%
We moreover give explicit connections to computability theory by specializing to
the category of assemblies over Kleene's first model.

\subsection{Double negation stable realizability predicates}\label{sec:double-negation-stable}

We have already seen that the monomorphisms of assemblies are given exactly by
realizability predicates. The \emph{regular} monos can be characterized as a
subset of those realizability predicates, namely those that are
\(\lnot\lnot\)-stable.

\begin{definition}[\(\lnot\lnot\)-stability]
  A realizability predicate \(\phi\) on an assembly \(X\) is said to be
  \textbf{\(\lnot\lnot\)-stable} if
  \[
    \forall(x : X).(\lnot\lnot\phi(x) \Rightarrow \phi(x))
  \]
  is realized.
\end{definition}

In some of the literature (on topos theory), one also sees the name
\emph{\(\lnot\lnot\)-closed}.
%
Bauer uses the word \emph{classical} in~\cite{Bauer2023}.
%
This is reasonable terminology, because in classical logic everything is
\(\lnot\lnot\)-stable. Moreover, as we will see the \(\lnot\lnot\)-stable
realizability predicates correspond to ordinary `classical' subsets.

In realizability, not all predicates are \(\lnot\lnot\)-stable, as we ask you to
verify by means of the following exercise:

\begin{exercise}\label{exer:not-double-negation-stable-predicate}
  Show that if all realizability predicates of \(\Asm{\AA}\) are
  \(\lnot\lnot\)-stable, then the pca \(\AA\) is trivial.

  \emph{Hint}: For \(\pca{a},\pca{b} \in \AA\), consider a suitable
  realizability predicate on \(\nabla\set{0,1}\).
\end{exercise}

In fact, we have already seen the \(\lnot\lnot\)-stable realizability predicates
because (seen as monomorphisms) they are precisely the regular monos, as we ask you
to verify.

\begin{exercise}\label{exer:double-negation-stable-iff-regular-mono}
  Prove that a realizability predicate \(\phi\) on an assembly \(X\) is
  \(\lnot\lnot\)-stable if and only if its corresponding monomorphism
  \([\phi] \hookrightarrow X\) is regular.
\end{exercise}

The \(\lnot\lnot\)-stable predicates have no computational content as made
precise by the following result:

\begin{proposition}\label{not-not-stable-ordinary-subsets}
  Every \(\lnot\lnot\)-stable realizability predicate \(\phi\) on an
  assembly \(X\) is uniquely determined by a subset \(A \subseteq \carrier{X}\)
  such that we have a pullback diagram
  \[
    \begin{tikzcd}
      {[\phi]} \ar[r] \ar[d,hookrightarrow] \pbcorner
      & \nabla A \ar[d,hookrightarrow] \\
      X \ar[r,"\eta_X"] & \nabla\carrier{X}
    \end{tikzcd}
  \]
  in \(\Asm{\AA}\).% , where we recall that \([\phi] \hookrightarrow X\) denotes
  % the mono corresponding to \(\phi\).
\end{proposition}
\begin{proof}
  Given a \(\lnot\lnot\)-stable realizability predicate \(\phi\) on \(X\), we
  define
  \[
    A \coloneqq \set{x \in \carrier{X} \mid \phi(x) \neq \emptyset} = \carrier{[\phi]}.
  \]
  %
  We may compute the pullback of \(\nabla A \hookrightarrow \nabla\carrier{X}\)
  along \(\eta_X\) as the assembly \(P\) with
  \[
    \carrier{P} \coloneqq A \quad\text{and}\quad
    \pca{a} \realizes_P x \iff a \realizes_X x.
  \]
  The identity on \(A\) gives functions between \(\carrier{[\phi]}\) and
  \(\carrier{P}\). It remains to see that they are tracked.
  %
  Towards \(P\), the map is tracked by \(\pcafst\). In the other direction, we
  get a tracker by the assumption that \(\phi\) is \(\lnot\lnot\)-stable.

  For the converse, we note that the above computation indeed shows that such a
  pullback corresponds to a \(\lnot\lnot\)-stable realizability predicate,
  because the realizers of the pullback are just the realizers of \(X\).
\end{proof}


In fact, the \(\lnot\lnot\)-stable realizability predicates arise as pullbacks
of a single map:

\begin{proposition}\label{nabla-two-classifies-not-not-stable}
  Every \(\lnot\lnot\)-stable realizability predicate \(\phi\) on an assembly
  \(X\) is uniquely determined by a map \(\chi \colon X \to \nabla\set{0,1}\)
  such that we have a pullback diagram
  \[
    \begin{tikzcd}
      {[\phi]} \ar[r] \ar[d,hookrightarrow] \pbcorner
      & \One \ar[d,hookrightarrow,"{\singleton \,\mapsto\, 1}"] \\
      X \ar[r,"\chi"] & \nabla\set{0,1}
    \end{tikzcd}
  \]
  in \(\Asm{\AA}\).
\end{proposition}
\begin{proof}
  Given \(A \subseteq \carrier{X}\), the map
  \(
    \chi' \colon \nabla X \to \nabla\set{0,1}\) with \(\chi'(x)
    = \begin{cases}
      0 &\text{if } x \not\in A \\
      1 &\text{if } x \in A
    \end{cases}
    \)

  gives a pullback square
  \[
    \begin{tikzcd}
      \nabla A \ar[r] \ar[d,hookrightarrow] \pbcorner
      & \One \ar[d,hookrightarrow,"{\singleton \,\mapsto\, 1}"] \\
      \nabla\carrier{X} \ar[r,"\chi'"] & \nabla\set{0,1}
    \end{tikzcd}
  \]
  so the result follows from
  \cref{not-not-stable-ordinary-subsets} and pullback pasting.
\end{proof}

The map \(\One \to \nabla\set{0,1}\) is said to be a \textbf{classifier} for the
\(\lnot\lnot\)-stable realizability predicates (subobjects).

Finally, we can also internalize \cref{not-not-stable-ordinary-subsets} as:
\begin{exercise}\label{exer:nabla-two-nat-exp}
  For an assembly \(X\), the exponential \(\pa*{\nabla\set{0,1}}^X\) is
  isomorphic to \(\nabla(\powerset(\carrier{X}))\).
\end{exercise}

\subsection{Decidable realizability predicates}\label{sec:decidable-realizability-predicates}

After the \(\lnot\lnot\)-stable realizability predicates we now consider the
subset of \emph{decidable} realizability predicates. We show these to be
classified by the assembly of booleans and explore the connection to computable
subsets in assemblies over Kleene's first model.

\begin{definition}[Decidability]
  A realizability predicate \(\phi\) on an assembly \(X\) is said to be
  \textbf{decidable} if
  \[
    \forall(x : X).(\phi(x) \lor \lnot\phi(x))
  \]
  is realized.
\end{definition}

The decidable realizability predicates form a subset of the \(\lnot\lnot\)-stable ones.

\begin{lemma}\label{decidable-implies-not-not-stable}
  Every decidable realizability predicate is \(\lnot\lnot\)-stable.
\end{lemma}
\begin{proof}
  This is a nice opportunity to make use of the soundness of constructive logic,
  so that we don't need to concern ourselves with realizers.
  %
  That is, we give a constructive proof that decidability implies
  \(\lnot\lnot\)-stability.
  %
  If \(\phi\) is decidable, then we only have to consider two cases: if
  \(\phi(x)\) holds, then we trivially get
  \(\lnot\lnot\phi(x) \Rightarrow \phi(x)\); while if \(\lnot\phi(x)\) hold,
  then the assumption \(\lnot\lnot\phi(x)\) leads to a contradiction, allowing
  us to conclude \(\phi(x)\).
\end{proof}

Notice that \cref{decidable-implies-not-not-stable} in combination with
\cref{exer:not-double-negation-stable-predicate} implies that not all
realizability predicates are decidable (unless the pca is trivial).

\begin{proposition}
  The decidable realizability predicates are classified by \(\Two\).
\end{proposition}
\begin{proof}
  Suppose \(\phi\) is a decidable realizability predicate on an assembly \(X\).
  %
  Then the function \(\chi \colon \carrier{X} \to \carrier{\Two}\) defined as

  \[
    \chi(x) \coloneqq
    \begin{cases}
      0 &\text{if } \phi(x) = \emptyset, \\
          1 &\text{if } \phi(x) \neq \emptyset;
    \end{cases}
  \]
  is tracked because \(\phi\) is decidable, so we get an assembly map
  \(\chi \colon X \to \Two\).
  %
  Computing the pullback \(P\) in
  \[
    \begin{tikzcd}
      P \ar[r] \ar[d,hookrightarrow] \pbcorner
      & \One \ar[d,hookrightarrow,"{\singleton \,\mapsto\, 1}"] \\
      X \ar[r,"\chi'"] & \Two
    \end{tikzcd}
  \]
  we get
  \[
    \carrier{P} \coloneqq \set{x \in \carrier{X} \mid \phi(x) \neq \emptyset}
    = \carrier{[\phi]}
    \quad\text{and}\quad
    \pca{a} \realizes_P x \iff \pca{a} \realizes_X x.
  \]
  But, recalling the proof of \cref{not-not-stable-ordinary-subsets}, we see
  that \(P\) and \([\phi]\) are isomorphic as \(\phi\) is \(\lnot\lnot\)-stable
  by~\cref{decidable-implies-not-not-stable}.

  Conversely, given such a pullback \([\phi]\), the tracker of \(X \to \Two\)
  witnesses the fact that \(\forall(x:X).\lnot\lnot\phi(x) \lor \lnot\phi(x)\)
  is realized.
  %
  But the square
  \[
    \begin{tikzcd}
      \One \pbcorner \ar[r] \ar[d] & \One \ar[d,"\star \mapsto 1"] \\
      \Two \ar[r,hookrightarrow] & \nabla\set{0,1}
    \end{tikzcd}
  \]
  is a pullback, so by pullback pasting we see that \([\phi]\) is classified by
  \(\nabla\set{0,1}\). Therefore, by~\cref{nabla-two-classifies-not-not-stable},
  the predicate \(\phi\) is \(\lnot\lnot\)-stable, so in fact
  \(\forall(x:X).\phi(x) \lor \lnot\phi(x)\) is realized, as desired.
\end{proof}

For the remainder of this subsection we take \(\AA \coloneqq \Kone\), i.e., we
work with assemblies over Kleene's first model (\cref{ex:Kleene-1}).

\begin{exercise}\label{exer:nno-in-Asm-K1}
  Show that the natural numbers object in \(\Asm{\Kone}\) is isomorphic to the
  assembly \(\NatAsm\) with carrier \(\Nat\) and realizers
  \(n \realizes_\NatAsm n\) for each \(n \in \Nat\).
\end{exercise}

Similarly, one may show that in \(\Asm{\Kone}\) we can take the numbers \(0\)
and \(1\) as the respective realizers of the elements \(0,1 \in \carrier{\Two}\)
of the assembly of booleans.

Recall from computability theory that a subset \(A \subseteq \Nat\) is
\textbf{computable} if we have a total (Turing) computable function
\(\chi \colon \Nat \to \Nat\) such that
%\(\chi(n) \in \set{0,1}\) for all
%\(n \in \Nat\) %(we include this requirement for convenience only)
%and
\(\chi(n) = 1 \iff n \in A\).
%
We say that \(\chi\) \textbf{computes} \(A\).
%
Note: instead of ``computable'', some (older) textbooks will use the terminology
``recursive'', or (potentially confusing for us) ``decidable''.

The following exercises show that the decidable realizability predicates of
\(\Asm{\Kone}\) correspond precisely to computable subsets.


\begin{exercise}\label{exer:decidable-is-computable}\leavevmode
  \begin{enumerate}[(i)]
  \item Show that the exponential \(\Two^\NatAsm\) is isomorphic to the assembly
    \(\CC\) with
    \begin{align*}
      \carrier{\CC} \,\coloneqq\, \set{&A \subseteq \Nat \mid A \text{ is computable}}, \text{and} \\
      n \realizes_{\CC} A \iff &\prenum{n} \text{ computes } A.
    \end{align*}
  \item Show that there is a bijection between computable subsets and pullback
    squares
    \[
      \begin{tikzcd}
        \bullet \pbcorner \ar[r] \ar[d,hookrightarrow]
        & \One \ar[d,"\star \mapsto 1"] \\
        \NatAsm \ar[r] & \Two
      \end{tikzcd}
    \]
  \item Conclude that there is a bijection between computable subsets and
    decidable realizability predicates on \(\NatAsm\).
  \end{enumerate}
\end{exercise}

% \begin{exercise}\label{exer:Two-computable-subsets}
%   Show that for an assembly \(X\), we have a bijection between
%   \begin{enumerate}[(i)]
%   \item pullbacks
%     \[
%       \begin{tikzcd}
%         \bullet \pbcorner \ar[r] \ar[d,hookrightarrow]
%         & \One \ar[d,"\star \mapsto 1"] \\
%         X \ar[r] & \Two
%       \end{tikzcd}
%     \]
%   \item subsets \(X' \subseteq X\) and computable subsets
%     \(A \subseteq \Nat\) such that for all \(x \in X\), we have
%     \begin{align*}
%       x \in X' &\Rightarrow \set{n \in \Nat \mid n \realizes_X x} \subseteq A, \text{and} \\
%       x \not\in X' &\Rightarrow \set{n \in \Nat \mid n \realizes_X x} \cap A = \emptyset.
%     \end{align*}
%   \end{enumerate}
%   In particular, for \(X \coloneqq \NatAsm\), we recover (cf.\
%   \cref{exer:Two-to-N-is-C}) the fact that assembly maps
%   \(\NatAsm \to \Two\) correspond to computable subsets.
% \end{exercise}

\subsection{Semidecidable realizability predicates}\label{sec:semidecidable-realizability-predicates}

We introduce a third and final class of realizability predicates: the
semidecidable ones.
\begin{definition}[Semidecidability]
  A realizability predicate \(\phi\) on an assembly \(X\) is said to be
  \textbf{semidecidable} if
  \[
    \forall(x : X).\exists(\sigma:\Two^\NatAsm).
    \pa*{\pa*{\exists(n : \NatAsm).\sigma(n) = 1}\iff\phi(x)}
  \]
  is realized.
\end{definition}

Notice the inherent essential asymmetry of semidecidability: the assertion that
the predicate is true can be made by making finitely many observations (keep
querying the sequence until we see a \(1\)); on the other hand, to conclude that
the predicate is false we would need evidence that the sequence is \(0\)
\emph{everywhere}.

\begin{definition}[Assembly of semidecidable truth values, \(\Sigma\)]
  The \textbf{assembly of semidecidable truth values}, denoted by \(\Sigma\),
  has carrier \(\set{0,1}\) and realizers
  \begin{align*}
    \pca{r} \realizes_\Sigma b \text{ such that}
    &\pca{r}\numeral{k} \in \set{\pcatrue,\pcafalse}
    \text{ for all \(k \in \Nat\), and we have} \\
    &\pa*{\exists(n \in \Nat).\pca{r}\numeral{n} = \pcatrue} \iff (b = 1).
  \end{align*}
\end{definition}

Thus, the realizers of \(\Sigma\) are codes for binary sequences of booleans and
such a code for a sequence realizes the element \(1\) precisely when the
sequence is true somewhere.
%
It should therefore come as no surprise that we have:
\begin{exercise}\label{exer:Sigma-classifies-semidecidable-realizability-predicates}
  The assembly \(\Sigma\) (with distinguished element
  \(1 \in \carrier{\Sigma}\)) classifies the semidecidable realizability
  predicates.
\end{exercise}

For the remainder of this subsection we again work with Kleene's first model only.
% and we explore the connections between
% \(\Sigma\) and computable enumerable subsets.

\begin{exercise}\label{exer:Sigma-in-Kleene-1}
  Show that \(\Sigma\) is isomorphic to the assembly \(\Sigma'\) with carrier
  \(\set{0,1}\) and realizers
  \[
    n \realizes_{\Sigma'} 0 \iff n \not\in K
    \quad\text{and}\quad
    n \realizes_{\Sigma'} 1 \iff n \in K,
  \]
  where \(K \coloneqq \set{n \in \Nat \mid \prenum{n}(n) \text{ is defined}}\)
  is the \emph{(diagonal) Halting set}.

  \emph{Note}: This requires a little bit of computability theory.
\end{exercise}

It follows from~\cref{exer:Sigma-in-Kleene-1} that while both inclusions
\[
  \Two \hookrightarrow \Sigma \hookrightarrow \nabla\set{0,1}
\]
are mono and epi, neither of them is regular mono or regular epi, as it would
imply (check!) that membership of the Halting set \(K\) is computable which it
(famously) isn't.

Recall from computability theory that a subset \(A \subseteq \Nat\) is
\textbf{computably enumerable} (or \textbf{c.e.} for short) if it is empty or if
we have a total computable function \(e \colon \Nat \to \Nat\) such that \(e\)
\textbf{enumerates} \(A\) in the sense that the image of \(e\) and \(A\) are
equal.
%
Note: instead of ``computably enumerable'', some (older) textbooks will use the terminology
``recursively enumerable'', or (potentially confusing for us) ``semidecidable''.
%
A standard example of a computably enumerable subset that is not computable is
the Halting set \(K\).

The following exercises explore the connections between the semidecidable
realizability predicates of \(\Asm{\Kone}\) and computably enumerable subsets.

\begin{exercise}\label{exer:Sigma-to-N-is-CE}
  Show that the exponential \(\Sigma^\NatAsm\) is isomorphic to the assembly
  \(\CE\) with
  \begin{align*}
    \carrier{\CE} \,\coloneqq\, \set{&A \subseteq \Nat \mid A \text{ is computably enumerable}}, \text{and} \\
    n \realizes_{\CE} A \iff &\prenum{n} \text{ enumerates } A.
  \end{align*}
\end{exercise}

\begin{exercise}\label{exer:Sigma-ce-subsets}
  Show that for an assembly \(X\), we have a bijection between
  \begin{enumerate}[(i)]
  \item pullbacks
    \[
      \begin{tikzcd}
        \bullet \pbcorner \ar[r] \ar[d,hookrightarrow]
        & \One \ar[d,"\star \mapsto 1"] \\
        X \ar[r] & \Sigma
      \end{tikzcd}
    \]
  \item subsets \(X' \subseteq X\) and c.e.\ subsets
    \(A \subseteq \Nat\) such that for all \(x \in X\), we have
    \begin{align*}
      x \in X' &\Rightarrow \set{n \in \Nat \mid n \realizes_X x} \subseteq A, \text{and} \\
      x \not\in X' &\Rightarrow \set{n \in \Nat \mid n \realizes_X x} \cap A = \emptyset.
    \end{align*}
  \end{enumerate}
  In particular, taking \(X \coloneqq \NatAsm\), we see that semidecidable
  realizability predicates on \(\NatAsm\) correspond to computably
  enumerable subsets.
\end{exercise}

Recall \textbf{Rice's Theorem} from computability theory:

%
\begin{theorem*}[Rice]
  Suppose that \(P\) is a subset of\/ \(\Nat\) such that
  \begin{enumerate}[(i)]
  \item \(P\) is an \emph{index set}: if \(n \in P\) and \(\prenum{n} = \prenum{m}\), then \(m \in P\);
  \item \(P\) is \emph{nontrivial}, i.e.\ \(P \neq \emptyset\) and \(P \neq \Nat\).
  \end{enumerate}
  Then \(P\) is not computable.
\end{theorem*}

Rice's Theorem is often informally phrased as: ``every nontrivial semantic
property of partial computable functions is undecidable''.

In the category \(\Asm{\Kone}\) it has the following incarnation:
\begin{exercise}\label{exer:Rice-consequence}
  Show that the exponential \(\Two^\CE \cong \Two^{\pa*{\Sigma^\NatAsm}}\) is isomorphic to \(\Two\).
\end{exercise}

\section{Very first steps in synthetic computability theory}\label{sec:synthetic}

We end this chapter by giving an example of \emph{synthetic computability
theory}~\cite{Bauer2006}.
%
At a high level, the idea is to use the internal logic of \(\Asm{\Kone}\) to
develop computability theory\footnote{Really, the internal logic of the
  realizability topos; see~\cref{chap:topos}.}.
%
The point of restricting to the internal logic is that everything is
automatically computable: you never need to check computability or reason
explicitly about Turing machines for example.
%
A downside (depending on your perspective) is that we have to give up on using
classical logic, because it is not valid in the category as we have seen.

In computability theory, a basic but fundamental result is the following:

\begin{theorem*}[Post]
  If \(A \subseteq \Nat\) and its complement \(\Nat \setminus A\) are computably
  enumerable, then \(A\) is computable.
\end{theorem*}

It is not hard to prove this theorem, but we use it here as an illustration of
what a synthetic development might look like.

\begin{theorem}[Post's theorem, synthetically]\label{Post-synthetically}
  For a realizability predicate \(\phi\) on an assembly \(X \in \Asm{\Kone}\),
  if \(\phi\) and \(\lnot\phi\) are semidecidable, then \(\phi\) is decidable.
\end{theorem}

We prove \cref{Post-synthetically} via two general lemmas.
%
However, the final argument will need one additional logical axiom, namely Markov's
Principle, that is not provable in plain constructive logic, but that it is
valid in the internal logic of \(\Asm{\Kone}\).

\begin{definition}[Markov's Principle]
  The statement that every binary sequence that is not \(0\) everywhere must
  contain a \(1\) is known as \textbf{Markov's Principle}.
  %
  More formally, it is the statement:
  \[
    \forall\pa[\big]{\sigma:\Two^\NatAsm}.  \lnot(\forall(n : \NatAsm).\sigma(n)
    = 0) \Rightarrow (\exists(n : \NatAsm).\sigma(n) = 1).
  \]
\end{definition}

\begin{exercise}\label{exer:Markov's-Principle}\leavevmode
  \begin{enumerate}[(i)]
  \item Show that Markov's Principle is equivalent---over constructive logic---to
    \[
      \forall\pa[\big]{\sigma:\Two^\NatAsm}.  \lnot\lnot(\exists(n :
      \NatAsm).\sigma(n) = 1) \Rightarrow (\exists(n : \NatAsm).\sigma(n) = 1).
    \]
  \item Show that Markov's Principle is realized if and only if every
    semidecidable realizability predicate is \(\lnot\lnot\)-stable.
  \item Show that Markov's Principle is realized over \(\Kone\).
  \end{enumerate}
\end{exercise}

As announced, we now prove two general lemmas. Note that the proofs make no
mention of computability and simply restrict to constructively sound reasoning.

\begin{lemma}\label{semidecidable-closed-under-or}
  If \(\phi\) and \(\psi\) are semidecidable realizability predicates on an
  assembly \(X\), then \(\phi \lor \psi\) is again semidecidable.
\end{lemma}
\begin{proof}
  Let \(x \in \carrier{X}\) be arbitrary.
  %
  We reason purely in constructive logic.
  %
  Suppose there exist binary sequences \(\sigma\) and \(\tau\) such that
  \[
    (\exists(n:\Nat).\sigma(n) = 1) \iff \phi(x)
    \quad\text{and}\quad
    (\exists(n:\Nat).\tau(n) = 1) \iff \psi(x).
  \]
  Then
  \[
    (\exists(n:\Nat).(\sigma\oplus\tau)(n) = 1) \iff \phi(x) \lor \psi(x),
  \]
  where \(\sigma\oplus\tau\) is the binary sequence obtained by taking the
  maximum of the outputs of \(\sigma\) and \(\tau\) at each index.
\end{proof}

\begin{lemma}\label{not-not-decidable}
  For any realizability predicate \(\phi\), the statement
  \[
    \forall (x : X).\lnot\lnot(\phi(x) \lor \lnot \phi(x))
  \] is realized.
\end{lemma}
\begin{proof}
  We show that \(\lnot\lnot(p \lor \lnot p)\) holds generally in constructive
  logic.
  %
  Assume \(\lnot(p \lor \lnot p)\) with the aim of deriving a contradiction.
  %
  Since \(p\) implies \(p \lor \lnot p\), we derive \(\lnot p\).
  %
  But then \(p \lor \lnot p\) holds again which contradicts our assumption.
\end{proof}

We are now ready to prove \cref{Post-synthetically}:
\begin{proof}[Proof of \cref{Post-synthetically}]
  Suppose that \(\phi\) and \(\lnot\phi\) are semidecidable.
  %
  By \cref{semidecidable-closed-under-or} we know that \(\phi\lor\lnot\phi\) is
  again semidecidable.
  %
  Moreover, by Markov's Principle, the predicate \(\phi\lor\lnot\phi\) is
  \(\lnot\lnot\)-stable.
  %
  But \(\forall(x:X).\lnot\lnot(\phi(x)\lor\lnot\phi(x))\) is realized by
  \cref{not-not-decidable}, so we get \(\forall(x:X).\phi(x)\lor\lnot\phi(x)\),
  i.e.\ \(\phi\) is decidable, as desired.
\end{proof}

Once again, we stress the purely logical flavour of the above arguments---with
the exception of checking that Markov's Principle is valid in \(\Asm{\Kone}\)
which should be done once and can then be taken as an additional axiom to the
synthetic development.

Finally, we recover Post's result by specializing \cref{Post-synthetically} to
the assembly of natural numbers and by exploiting the correspondence between the
(semi)decidable realizability predicates and computable/c.e.\ subsets as
explored in
\cref{sec:decidable-realizability-predicates,sec:semidecidable-realizability-predicates}.



\section{List of exercises}
\begin{enumerate}
\item \cref{exer:preorders-monos-predicates-iso}: On monomorphisms as
  realizability predicates and vice versa.
\item \cref{exer:predicates-heyting-prealgebra}: On the Heyting prealgebra of
  realizability predicates.
\item \cref{exer:exists-predicate}: On \(\exists_f\) being left adjoint to
  \(f^\ast\) as maps between preorders of realizability predicates.
\item \cref{exer:epis-monos-logically}: On logical characterizations of
  (regular) epis and monos.
\item \cref{exer:not-double-negation-stable-predicate}: On the fact that not all
  realizability predicates are \(\lnot\lnot\)-stable.
\item \cref{exer:double-negation-stable-iff-regular-mono}: On the
  \(\lnot\lnot\)-stable realizability predicates as the regular monos.
\item \cref{exer:nabla-two-nat-exp}: On exponentials of \(\nabla\set{0,1}\).
\item \cref{exer:nno-in-Asm-K1}: On the natural numbers object in
  \(\Asm{\Kone}\).
\item \cref{exer:decidable-is-computable}: On the correspondence between
  decidable realizability predicates in \(\Asm{\Kone}\) and computable subsets
  of the natural numbers.
\item \cref{exer:Sigma-classifies-semidecidable-realizability-predicates}: On
  the classifier of semidecidable realizability predicates.
\item \cref{exer:Sigma-in-Kleene-1}: On the assembly of semidecidable truth
  values in \(\Asm{\Kone}\).
\item \cref{exer:Sigma-to-N-is-CE}: On computably enumerable subsets and the
  exponential of the assemblies of natural numbers and semidecidable truth
  values in \(\Asm{\Kone}\).
\item \cref{exer:Sigma-ce-subsets}: On computably enumerable subsets and
  pullbacks of the assembly of semidecidable truth values in \(\Asm{\Kone}\).
\item \cref{exer:Rice-consequence}: On Rice's theorem in \(\Asm{\Kone}\).
\item \cref{exer:Markov's-Principle}: On Markov's Principle.
\end{enumerate}

%%% Local Variables:
%%% mode: latexmk
%%% TeX-master: "../MGS-categorical-realizability"
%%% End:
